package net.nitroservices.rezan.mlforandroidmalwaredetection;


import java.io.UnsupportedEncodingException;

import java.util.ArrayList;
import java.util.Arrays;

/**
 * Created by rezan on 12/3/16.
 */

public class IPStringBuilder {

    private int a;
    private int b;
    private int c;
    private int d;
    private int e;
    private int f;
    private int g;
    private int h;
    private int i;
    private int j;
    private int k;
    private int l;
    private d m;
    private ArrayList n = new ArrayList();

    public IPStringBuilder(byte[] var1) throws cException {
        this.a = var1[28] << 8 | 255 & var1[29];
        this.b = (255 & var1[30]) >> 7;
        this.c = (120 & var1[30]) >> 3;
        this.d = (4 & var1[30]) >> 2;
        this.e = (2 & var1[30]) >> 1;
        this.f = 1 & var1[30];
        this.g = 1 & var1[31];
        this.h = 15 & var1[31];
        this.i = var1[32] << 8 | 255 & var1[33];
        this.j = var1[34] << 8 | 255 & var1[35];
        this.k = var1[36] << 8 | 255 & var1[37];
        this.l = var1[38] << 8 | 255 & var1[39];
        if(this.i == 1 && (this.b != 0 || this.j == 0 && this.k == 0) && this.e != 1) {
            String var2 = a(var1, 40);
            int var3 = 1 + b(var1, 40);
            int var4 = var1[var3] << 8;
            int var5 = var3 + 1;
            int var6 = var4 | 255 & var1[var5];
            int var7 = var5 + 1;
            int var8 = var1[var7] << 8;
            int var9 = var7 + 1;
            this.m = new d(this, var2, var6, var8 | 255 & var1[var9]);
            if(this.b != 0) {
                int var10 = var9 + 1;
                int var11 = 0;

                int var69;
                for(int var12 = var10; var11 < this.j + this.k && 1500 - var12 >= 11; var12 = var69) {
                    String var13 = a(var1, var12);
                    int var14 = 1 + var12 + 1;
                    int var15 = var1[var14] << 8;
                    int var16 = var14 + 1;
                    int var17 = var15 | 255 & var1[var16];
                    int var18 = var16 + 1;
                    int var19 = var1[var18] << 8;
                    int var20 = var18 + 1;
                    int var21 = var19 | 255 & var1[var20];
                    int var22 = var20 + 1;
                    int var23 = var1[var22] << 24;
                    int var24 = var22 + 1;
                    int var25 = var23 | (255 & var1[var24]) << 16;
                    int var26 = var24 + 1;
                    int var27 = var25 | (255 & var1[var26]) << 8;
                    int var28 = var26 + 1;
                    int var29 = var27 | 255 & var1[var28];
                    int var30 = var28 + 1;
                    int var31 = var1[var30] << 8;
                    int var32 = var30 + 1;
                    int var33 = var31 | 255 & var1[var32];
                    String var68;
                    switch(var17) {
                        case 1:
                            ++var32;
                            var68 = c(var1, var32);
                            break;
                        case 2:
                            ++var32;
                            var68 = a(var1, var32, var33);
                            break;
                        case 5:
                            ++var32;
                            var68 = a(var1, var32, var33);
                            break;
                        case 6:
                            StringBuilder var34 = new StringBuilder(String.valueOf(""));
                            int var35 = var32 + 1;
                            String var36 = var34.append(a(var1, var35, var33)).toString();
                            int var37 = var35 + b(var1, var35, var33);
                            if(var35 + var33 - var37 > 20) {
                                var36 = var36 + "," + a(var1, var37, var33);
                                var37 += -1 + b(var1, var37, var33);
                            }

                            StringBuilder var38 = (new StringBuilder(String.valueOf(var36))).append(",");
                            int var39 = var37 + 1;
                            int var40 = var1[var39] << 24;
                            int var41 = var39 + 1;
                            int var42 = var40 | (255 & var1[var41]) << 16;
                            int var43 = var41 + 1;
                            int var44 = var42 | (255 & var1[var43]) << 8;
                            int var45 = var43 + 1;
                            StringBuilder var46 = (new StringBuilder(String.valueOf(var38.append(var44 | 255 & var1[var45]).toString()))).append(",");
                            int var47 = var45 + 1;
                            int var48 = var1[var47] << 24;
                            int var49 = var47 + 1;
                            int var50 = var48 | (255 & var1[var49]) << 16;
                            int var51 = var49 + 1;
                            int var52 = var50 | (255 & var1[var51]) << 8;
                            int var53 = var51 + 1;
                            StringBuilder var54 = (new StringBuilder(String.valueOf(var46.append(var52 | 255 & var1[var53]).toString()))).append(",");
                            int var55 = var53 + 1;
                            int var56 = var1[var55] << 24;
                            int var57 = var55 + 1;
                            int var58 = var56 | (255 & var1[var57]) << 16;
                            int var59 = var57 + 1;
                            int var60 = var58 | (255 & var1[var59]) << 8;
                            int var61 = var59 + 1;
                            StringBuilder var62 = (new StringBuilder(String.valueOf(var54.append(var60 | 255 & var1[var61]).toString()))).append(",");
                            int var63 = var61 + 1;
                            int var64 = var1[var63] << 24;
                            int var65 = var63 + 1;
                            int var66 = var64 | (255 & var1[var65]) << 16;
                            int var67 = var65 + 1;
                            var68 = var62.append(var66 | (255 & var1[var67]) << 8 | 255 & var1[var67 + 1]).toString();
                            var32 = var35;
                            break;
                        case 15:
                            int var71 = var32 + 1;
                            int var72 = var1[var71] << 8;
                            int var73 = var71 + 1;
                            StringBuilder var74 = new StringBuilder(String.valueOf((var72 | 255 & var1[var73]) + ","));
                            int var75 = var73 + 1;
                            var68 = var74.append(a(var1, var75, var33)).toString();
                            var32 = var75 - 2;
                            break;
                        case 28:
                            ++var32;
                            var68 = d(var1, var32);
                            break;
                        default:
                            var68 = "Unsupported type";
                    }

                    var69 = var32 + var33;
                    this.n.add(new b(this, var13, var17, var21, var29, var33, var68));
                    ++var11;
                }
            }

        } else {
            throw new cException(this);
        }
    }

    public static String a(byte[] var0, int var1) {
        if(var1 >= 1500) {
            return "TooLongDNS";
        } else {
            StringBuilder var2 = new StringBuilder();
            byte var10000 = var0[var1];

            byte var5;
            for(int var4 = var1; var4 < 1500 && var0[var4] != 0; var4 = 1 + var4 + var5) {
                if(var4 != var1) {
                    var2.append(".");
                }

                if((192 & var0[var4]) == 192) {
                    var2.append(a(var0, 28 + ((63 & var0[var4]) << 8 | 255 & var0[var4 + 1])));
                    break;
                }

                var5 = var0[var4];

                try {
                    var2.append(new String(Arrays.copyOfRange(var0, var4 + 1, 1 + var4 + var5), "UTF-8"));
                } catch (UnsupportedEncodingException var8) {
                    var8.printStackTrace();
                } catch (IllegalArgumentException var9) {
                    var9.printStackTrace();
                }
            }

            return var2.toString();
        }
    }

    private static String a(byte[] var0, int var1, int var2) {
        if(var1 >= 1500) {
            return "TooLongDNS";
        } else {
            StringBuilder var3 = new StringBuilder();
            byte var10000 = var0[var1];

            byte var6 = 0;
            for(int var5 = var1; var5 < 1500 && var0[var5] != 0 || var5 - var1 >= var2; var5 += var6 + 1) {
                if(var5 != var1) {
                    var3.append(".");
                }

                if((192 & var0[var5]) == 192) {
                    var3.append(a(var0, 28 + ((63 & var0[var5]) << 8 | 255 & var0[var5 + 1])));
                    break;
                }

                var6 = var0[var5];

                try {
                    var3.append(new String(Arrays.copyOfRange(var0, var5 + 1, 1 + var5 + var6), "UTF-8"));
                } catch (UnsupportedEncodingException var9) {
                    var9.printStackTrace();
                } catch (IllegalArgumentException var10) {
                    var10.printStackTrace();
                }
            }

            return var3.toString();
        }
    }

    private static int b(byte[] var0, int var1) {
        while(var0[var1] != 0 && var1 < 1500) {
            ++var1;
        }

        return var1;
    }

    private static int b(byte[] var0, int var1, int var2) {
        int var3 = 0;
        int var4 = var1;

        while(true) {
            if(var4 >= var1 + var2 || var4 >= 1500) {
                var3 = -1;
                break;
            }

            ++var3;
            if(var0[var4] == 192) {
                return var3 + 1;
            }

            if(var0[var4] == 0) {
                break;
            }

            ++var4;
        }

        return var3;
    }

    private static String c(byte[] var0, int var1) {
        if(1500 - var1 < 4) {
            return "TooLongDNS";
        } else {
            StringBuilder var2 = new StringBuilder();

            for(int var3 = 0; var3 < 4; ++var3) {
                if(var3 != 0) {
                    var2.append(".");
                }

                var2.append(255 & var0[var1 + var3]);
            }

            return var2.toString();
        }
    }

    private static String d(byte[] var0, int var1) {
        if(1500 - var1 < 16) {
            return "TooLongDNS";
        } else {
            StringBuilder var2 = new StringBuilder();

            for(int var3 = 0; var3 < 16; ++var3) {
                if(var3 % 2 == 0 && var3 != 0) {
                    var2.append(":");
                }

                Object[] var4 = new Object[]{Integer.valueOf(255 & var0[var1 + var3])};
                var2.append(String.format("%02x", var4));
            }

            return var2.toString();
        }
    }

    public d a() {
        return this.m;
    }

    public ArrayList b() {
        return this.n;
    }
}
